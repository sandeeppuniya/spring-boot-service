package com.example.controller;

import com.example.service.FileMetadata;
import com.example.service.FileService;
import org.apache.log4j.Logger;
import org.apache.tomcat.util.http.fileupload.IOUtils;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;
import com.example.service.FileData;

import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.util.Date;
import java.util.List;

/**
 * Spring boot restful api to support the following API calls:
 * <p>
 * 1. API to upload a file with a few meta-data fields. Persist meta-data in persistence store (In memory DB or file system and store the content on a file system)
 * 2. API to get file meta-data
 * 3. API to download content stream
 * 4. API to search for file IDs with a search criterion
 * 5. A scheduler to poll for files added in last hour and send an email if files were added.
 */
@RestController
@EnableAutoConfiguration
@ComponentScan
@EnableScheduling
public class SpringBootServiceApplication {

    private static final String APPLICATION_CONTEXT = "application-context.xml";
    private ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(APPLICATION_CONTEXT);

    private FileService fileService = context.getBean(FileService.class);
    private static final Logger LOG = Logger.getLogger(SpringBootServiceApplication.class);

    /**
     * Adds a file to the file store.
     *
     * @param inputFile A multipart file posted to the API.
     * @return output Output response containing the fileName and fileId(unique identifier generated by the API) of the input file.
     * @throws IOException Throws IOException when the temporary store of the file fails.
     */
    @RequestMapping(value = "/uploadFile", method = RequestMethod.POST)
    @ResponseBody
    public FileMetadata uploadFile(@RequestParam(value = "file", required = true) MultipartFile inputFile) throws IOException {
        final String methodName = "uploadFile() : Entry";
        LOG.info(methodName);

        byte[] fileBytes = inputFile.getBytes();
        FileData file = new FileData(fileBytes, inputFile.getOriginalFilename());
        file.setCreationTime(new Date().getTime());
        fileService.save(file, context);

        FileMetadata output = new FileMetadata();
        output.setFileName(file.getFileName());
        output.setFileId(file.getFileId());
        output.setCreationTime(file.getCreationTime());

        return output;
    }

    /**
     * Returns a list of all the matching files from the 'file store' if there is a match on the input filename. Otherwise, returns empty list.
     *
     * @param fileName Name of the input file to be searched in the 'file system'.
     * @return A list of file metadata from the file system.
     */
    @RequestMapping(value = "/getFileMetadata", method = RequestMethod.GET)
    public HttpEntity<List<FileMetadata>> getFileMetadata(@RequestParam(value = "fileName", required = true) String fileName) {
        final String methodName = "getFileMetadata() : Entry";
        LOG.info(methodName);

        HttpHeaders httpHeaders = new HttpHeaders();
        return new ResponseEntity<List<FileMetadata>>((List<FileMetadata>) fileService.findFile(fileName, context), httpHeaders, HttpStatus.OK);
    }

    @RequestMapping(value = "/getFileMetadataById", method = RequestMethod.GET)
    public HttpEntity<List<FileMetadata>> getFileMetadataById(@RequestParam(value = "fileName", required = true) String fileId) {
        final String methodName = "getFileMetadataById() : Entry";
        LOG.info(methodName);

        HttpHeaders httpHeaders = new HttpHeaders();
        return new ResponseEntity<List<FileMetadata>>((List<FileMetadata>) fileService.findFileById(fileId, context), httpHeaders, HttpStatus.OK);
    }

    /**
     * Returns a stream of the matched FileData object based on the input fileId.
     *
     * @param fileId   Input file id to be searched in the file store.
     * @param response Response stream
     * @throws IOException Throws IOException when fails to get the output stream from the selected FileMetadata object.
     */
    @RequestMapping(value = "/downloadFileStream", method = RequestMethod.GET)
    public void downloadFileStream(@RequestParam(value = "fileId", required = true) String fileId, HttpServletResponse response) throws IOException {
        final String methodName = "downloadFileStream() : Entry";
        LOG.info(methodName);

        List<FileData> fileDatas = (List<FileData>) fileService.findFileData(fileId, context);
        response.addHeader("Content-disposition", "DownloadFile");
        response.setContentType("txt/plain");

        if (fileDatas.size() != 0) {
            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
            for (FileData fileData : fileDatas) {
                outputStream.write(fileData.getFileData());
            }
            InputStream inputStream = getInputStream(outputStream.toByteArray());
            IOUtils.copy(inputStream, response.getOutputStream());
            response.flushBuffer();
        }
    }

    /**
     * Gets the input stream from the matched FileMetadata objects.
     *
     * @param fileDataBytes FileData object
     * @return
     * @throws IOException
     */
    private InputStream getInputStream(byte[] fileDataBytes) throws IOException {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
        objectOutputStream.writeObject(fileDataBytes);
        objectOutputStream.flush();
        objectOutputStream.close();
        return new ByteArrayInputStream(byteArrayOutputStream.toByteArray());
    }

    /**
     * Main method to deploy the service.
     *
     * @param args Input string array
     */
    public static void main(String[] args) {
        SpringApplication.run(SpringBootServiceApplication.class, args);
    }
}
